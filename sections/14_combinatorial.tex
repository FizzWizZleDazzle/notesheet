\section{Combinatorial Search}
% ============================================================

\subsection{Generating Permutations}
\begin{desc}
Produces all $n!$ orderings of an array via \textbf{swap-based backtracking}.\\
\textbf{Approach}: at depth $l$, try each remaining element in position $l$,
recurse, then swap back (backtrack).\\
Feasible for $n \le 10$ ($10! = 3.6$ million).\\
Use for brute-force search over all orderings.
\end{desc}
\complexity{$O(n \cdot n!)$}{$O(n)$ for recursion depth}
\begin{lstlisting}
static void permute(int[] a, int l,
    List<int[]> res) {
  if (l == a.length - 1) {
    res.add(a.clone());
    return;
  }
  for (int i = l; i < a.length; i++) {
    int t = a[l]; a[l] = a[i]; a[i] = t;
    permute(a, l + 1, res);
    t = a[l]; a[l] = a[i]; a[i] = t; // backtrack
  }
}
\end{lstlisting}

\subsection{Generating Subsets via Bitmask}
\begin{desc}
Iterates all $2^n$ subsets using integers as bitmasks.
Bit $i$ set to 1 means element $i$ is included.\\
Feasible for $n \le 20$ ($2^{20} \approx 1$ million).\\
Use for subset enumeration, set cover, finding optimal subsets.
\end{desc}
\complexity{$O(n \cdot 2^n)$ to process all subsets}{$O(n)$ per subset}
\begin{lstlisting}
for (int mask = 0; mask < (1 << n); mask++){
  var subset = new ArrayList<Integer>();
  for (int i = 0; i < n; i++)
    if ((mask & (1 << i)) != 0)
      subset.add(a[i]);
  // process subset
}
\end{lstlisting}

\subsection{Bit Manipulation Tricks}
\begin{desc}
Essential operations for bitmasks, optimization, and low-level tricks.
\end{desc}
\complexity{All operations: $O(1)$}{$O(1)$}
\begin{lstlisting}
x & 1          // is x odd?
x >> 1         // divide by 2 (signed shift)
x << 1         // multiply by 2
x & (x - 1)   // clear lowest set bit
x & (-x)       // isolate lowest set bit (LSB)
Integer.bitCount(x);  // count set bits (popcount)

// Individual bit operations
x | (1 << i)   // set bit i to 1
x & ~(1 << i)  // clear bit i to 0
x ^ (1 << i)   // toggle bit i
(x >> i) & 1   // check if bit i is set

// Power of 2 check
(x & (x - 1)) == 0 && x > 0

// Sign extension
int sign = (x >> 31);  // -1 if negative, 0 if positive
\end{lstlisting}

% ============================================================
