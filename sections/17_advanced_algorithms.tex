\section{Advanced Algorithms}
% ============================================================

\subsection{Gaussian Elimination (mod 2)}
\begin{desc}
Solves systems of \textbf{XOR equations} (linear algebra over $\text{GF}(2)$).
Each variable is 0 or 1; addition is XOR ($\oplus$).\\
\textbf{Applications}: switch/light toggle problems, parity-based puzzles,
cryptanalysis, error-correcting codes.\\
\textbf{Approach}: row-reduce the augmented matrix. For each column (variable),
find a pivot row with 1 in that column, swap it into position, then XOR all
other rows that have 1 in that column to eliminate them.
\end{desc}
\complexity{$O(n^2 m)$ where $n$ = variables, $m$ = equations}{$O(nm)$}
\begin{lstlisting}
// A[i][j] = coefficient of variable j in equation i
// b[i] = right-hand side of equation i
static int[] solveXOR(boolean[][] A,
    boolean[] b, int n) {
  for (int col = 0; col < n; col++) {
    // Find pivot
    int piv = -1;
    for (int r = col; r < b.length; r++)
      if (A[r][col]) { piv = r; break; }
    if (piv == -1) continue; // no pivot, skip

    // Swap pivot row into position
    var tmp = A[col]; A[col] = A[piv]; A[piv] = tmp;
    var t = b[col]; b[col] = b[piv]; b[piv] = t;

    // Eliminate column from all other rows
    for (int r = 0; r < b.length; r++) {
      if (r != col && A[r][col]) {
        for (int c = 0; c < n; c++)
          A[r][c] ^= A[col][c];
        b[r] ^= b[col];
      }
    }
  }
  // Read solution
  var sol = new int[n];
  for (int i = 0; i < n; i++)
    sol[i] = b[i] ? 1 : 0;
  return sol;
}
\end{lstlisting}

\subsection{Multi-Source BFS (Simultaneous Expansion)}
\begin{desc}
When multiple sources grow outward simultaneously (e.g., fire spreading from
multiple points, flood fill from multiple origins), enqueue \textbf{all sources}
at the start. Process in order of distance/time using a priority queue or
level-by-level BFS.\\
\textbf{Key}: the first arrival at each cell claims it.\\
Common in simulation, growth modeling, and multi-agent pathfinding.
\end{desc}
\complexity{$O((V+E) \log V)$ with PQ, or $O(V+E)$ with level-based BFS}{$O(V)$}
\begin{lstlisting}
// Priority queue entry: {time, row, col, sourceId}
var pq = new PriorityQueue<int[]>(
  Comparator.comparingInt(a -> a[0]));
var owner = new int[W][W];
for (var row : owner) Arrays.fill(row, -1);

// Enqueue all sources with their start times
for (int i = 0; i < sources.length; i++) {
  int r = sources[i][0], c = sources[i][1];
  int startTime = times[i];
  pq.offer(new int[]{startTime, r, c, i});
}

while (!pq.isEmpty()) {
  var cur = pq.poll();
  int t = cur[0], r = cur[1];
  int c = cur[2], id = cur[3];
  if (owner[r][c] != -1) continue; // already claimed
  owner[r][c] = id;

  for (int d = 0; d < 4; d++) {
    int nr = r + DR[d], nc = c + DC[d];
    if (nr>=0 && nr<W && nc>=0 && nc<W
        && owner[nr][nc] == -1)
      pq.offer(new int[]{t+1, nr, nc, id});
  }
}
\end{lstlisting}

\subsection{Game Theory --- Minimax}
\begin{desc}
When two players alternate making optimal decisions, use \textbf{minimax}.\\
\textbf{Core idea}: the current player maximizes their score; the opponent
(next player) minimizes it (from current player's perspective).\\
With memoization on game state, avoids re-exploring identical positions.\\
\textbf{Applications}: game AI (chess, tic-tac-toe), optimal play analysis,
adversarial search.
\end{desc}
\complexity{$O(\text{states} \cdot \text{moves per state})$ with memoization}{$O(\text{states})$}
\begin{lstlisting}
// Minimax with memoization
var memo = new HashMap<State, Integer>();

static int minimax(State s, boolean myTurn) {
  if (s.isTerminal()) return s.score();
  if (memo.containsKey(s))
    return memo.get(s);

  int best = myTurn
    ? Integer.MIN_VALUE  // maximize
    : Integer.MAX_VALUE; // minimize
  for (var next : s.possibleMoves()) {
    int val = minimax(next, !myTurn);
    best = myTurn
      ? Math.max(best, val)
      : Math.min(best, val);
  }
  memo.put(s, best);
  return best;
}
\end{lstlisting}

\subsection{Interval Scheduling (Greedy)}
\begin{desc}
Select the \textbf{maximum number of non-overlapping intervals}.\\
\textbf{Algorithm}: sort by end time; greedily pick each interval whose start
$\ge$ last chosen end. Optimal by an exchange argument.\\
\textbf{Variant --- task with deadlines}: sort by duration (shortest first)
to minimize total lateness.
\end{desc}
\complexity{$O(n \log n)$}{$O(1)$}
\begin{lstlisting}
// Max non-overlapping intervals; intervals = {{start,end},...}
static int maxSchedule(int[][] ivs) {
  Arrays.sort(ivs, Comparator.comparingInt(a->a[1]));
  int count = 0, lastEnd = Integer.MIN_VALUE;
  for (var iv : ivs)
    if (iv[0] >= lastEnd) {
      count++; lastEnd = iv[1];
    }
  return count;
}

// Min removals so no two intervals overlap
static int minRemove(int[][] ivs) {
  return ivs.length - maxSchedule(ivs);
}
\end{lstlisting}

\subsection{Meet in the Middle}
\begin{desc}
Split input into \textbf{two halves}, enumerate all $2^{n/2}$ combinations for
each half, then combine---reducing $O(2^n)$ to $O(2^{n/2} \cdot n)$.\\
\textbf{Typical use}: subset-sum / 4-sum for $n \le 40$.\\
\textbf{Pattern}: enumerate first half $\to$ sort $\to$ for each second-half state,
binary search for complement.
\end{desc}
\complexity{$O(2^{n/2} \cdot n)$}{$O(2^{n/2})$}
\begin{lstlisting}
// Does any subset of a[] sum to target? (n <= 40)
static boolean meetMiddle(long[] a, long target) {
  int n = a.length, h = n / 2;
  // All subset sums of first half
  var left = new ArrayList<Long>();
  for (int m = 0; m < (1 << h); m++) {
    long s = 0;
    for (int i = 0; i < h; i++)
      if ((m >> i & 1) == 1) s += a[i];
    left.add(s);
  }
  Collections.sort(left);
  // Check second half
  for (int m = 0; m < (1 << (n-h)); m++) {
    long s = 0;
    for (int i = 0; i < n-h; i++)
      if ((m >> i & 1) == 1) s += a[h+i];
    if (Collections.binarySearch(left, target-s) >= 0)
      return true;
  }
  return false;
}
\end{lstlisting}

\subsection{Nim and Sprague-Grundy Theory}
\begin{desc}
\textbf{Nim}: $n$ heaps; alternate removing any amount from one heap; last
to move wins. Win iff \textbf{XOR of all pile sizes} $\ne 0$.\\
\textbf{Sprague-Grundy}: every impartial game state has a \textbf{Grundy number}
$g = \text{mex}\{g(\text{successors})\}$. $g=0$ = losing; $g>0$ = winning.
Combined games: XOR all Grundy numbers.
\end{desc}
\complexity{Nim: $O(n)$. Grundy: $O(S \cdot M)$ ($S$=states, $M$=moves/state)}{$O(S)$}
\begin{lstlisting}
// Nim: current player wins iff XOR != 0
static boolean nimWins(int[] piles) {
  int xor = 0;
  for (int p : piles) xor ^= p;
  return xor != 0;
}

// Grundy numbers for states 0..maxState
// nextStates(s) returns reachable states from s
static int[] computeGrundy(int maxState,
    java.util.function.IntFunction<int[]>
      nextStates) {
  var g = new int[maxState + 1];
  for (int s = 0; s <= maxState; s++) {
    var reach = new java.util.HashSet<Integer>();
    for (int t : nextStates.apply(s))
      reach.add(g[t]);
    int mex = 0;
    while (reach.contains(mex)) mex++;
    g[s] = mex;
  }
  return g;
  // Game of k piles: XOR g[pile_i]
  // == 0 => current player loses
}
\end{lstlisting}

% ============================================================
