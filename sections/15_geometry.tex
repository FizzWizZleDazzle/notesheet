\section{Geometry}
% ============================================================

\subsection{Collinearity (3D)}
\begin{desc}
Three points are collinear if the \textbf{cross product} of two vectors
formed by them is the zero vector ($\vec{AB} \times \vec{AC} = \vec{0}$).\\
Use an epsilon ($10^{-9}$ to $10^{-5}$) for floating-point tolerance.\\
Useful for checking if points lie on a line, which is common in computational geometry.
\end{desc}
\complexity{$O(1)$}{$O(1)$}
\begin{lstlisting}
record Pt3(double x, double y, double z) {}

static boolean collinear(
    Pt3 a, Pt3 b, Pt3 c) {
  double v1x = b.x()-a.x(), v1y = b.y()-a.y(),
    v1z = b.z()-a.z();
  double v2x = c.x()-a.x(), v2y = c.y()-a.y(),
    v2z = c.z()-a.z();
  // Cross product components
  double cx = v1y*v2z - v1z*v2y;
  double cy = v1z*v2x - v1x*v2z;
  double cz = v1x*v2y - v1y*v2x;
  double EPS = 1e-5;
  return Math.abs(cx) < EPS
    && Math.abs(cy) < EPS
    && Math.abs(cz) < EPS;
}
\end{lstlisting}

\subsection{2D Geometry Essentials}
\begin{desc}
Core 2D primitives: distance, area, and turn direction (cross product sign).\\
Cross product sign tells orientation: positive = counter-clockwise,
negative = clockwise, zero = collinear.\\
Essential for convex hull, polygon area, point-in-polygon tests.
\end{desc}
\complexity{All operations: $O(1)$}{$O(1)$}
\begin{lstlisting}
// Distance between two points
static double dist(double x1, double y1,
    double x2, double y2) {
  return Math.hypot(x2 - x1, y2 - y1);
}

// Triangle area (Shoelace formula)
static double triArea(double x1, double y1,
    double x2, double y2,
    double x3, double y3) {
  return Math.abs(
    x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)
  ) / 2.0;
}

// 2D cross product of vectors OA and OB
// > 0: A->B is counter-clockwise turn from O
// < 0: A->B is clockwise turn from O
// = 0: collinear
static long cross(long ox, long oy,
    long ax, long ay, long bx, long by) {
  return (ax-ox)*(by-oy) - (ay-oy)*(bx-ox);
}
\end{lstlisting}

\subsection{Convex Hull}
\begin{desc}
Finds the smallest convex polygon enclosing all given points.\\
\textbf{Andrew's monotone chain algorithm}: sort points by $(x, y)$,
build lower hull left-to-right, then upper hull right-to-left.
Remove a point if adding it makes a non-left (clockwise or straight) turn.\\
Useful in computational geometry, optimization, and polygon problems.
\end{desc}
\complexity{$O(n \log n)$}{$O(n)$}
\begin{lstlisting}
static long cross(long[] O, long[] A,
    long[] B) {
  return (A[0]-O[0])*(B[1]-O[1])
    - (A[1]-O[1])*(B[0]-O[0]);
}

static List<long[]> convexHull(long[][] pts) {
  int n = pts.length;
  if (n < 2) return List.of(pts);
  Arrays.sort(pts, Comparator
    .comparingLong((long[] p) -> p[0])
    .thenComparingLong(p -> p[1]));

  var hull = new long[2 * n][];
  int k = 0;

  // Build lower hull
  for (int i = 0; i < n; i++) {
    while (k >= 2 &&
      cross(hull[k-2], hull[k-1], pts[i]) <= 0)
      k--;
    hull[k++] = pts[i];
  }

  // Build upper hull
  int lower = k + 1;
  for (int i = n - 2; i >= 0; i--) {
    while (k >= lower &&
      cross(hull[k-2], hull[k-1], pts[i]) <= 0)
      k--;
    hull[k++] = pts[i];
  }

  return Arrays.asList(
    Arrays.copyOf(hull, k - 1));
}
\end{lstlisting}

% ============================================================
